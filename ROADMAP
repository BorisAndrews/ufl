Roadmap for the development of UFL
----------------------------------

FIXME: 04-01 vs 01-04 !!!

Suggestions:

# FIXME's from code:

"FIXME: Taking gradient of an expression with free indices, should this be a valid expression? Please provide examples!"
ufl_assert(len(f.free_indices()) == 0, "")

# FIXME: How to handle free indices in "non-index products" like this? In particular repeated indices?
return tuple(self.a.free_indices() + b.free_indices())

# FIXME: Maybe we don't need these afterall:
def BasisFunctions(element):
    if not isinstance(element, MixedElement):
        raise UFLException("Expecting MixedElement instance.")
    return tuple(BasisFunction(e) for e in element.elements) # FIXME: problem with count!

# FIXME: is this ok? Don't need QuadratureElement.
register_element("Quadrature",                   "Q",      0, (None, None), ("interval", "triangle", "tetrahedron", "quadrilateral", "hexahedron"))

# FIXME: functions evaluated on the boundary can't use quadrature points from the inside of the cell,
#        therefore we need to have a separate space for functions evaluated in quadrature points on the boundary:
register_element("Boundary Quadrature",          "BQ",     0, (None, None), ("interval", "triangle", "tetrahedron", "quadrilateral", "hexahedron"))


# Prettyness:
 - Rename geometry.py to builtins.py or something better.
 - Agree on name conventions, using "self._foo" or "self.foo"
   Suggested way to go: "self._foo" for everything the external user shouldn't use, which is most variables.
   In this case the "user" is the end-user, not form compiler people.
 - Improve parentesis use in __str__ and __repr__, use precedence list

# Derivatives:
 - Test partial derivative operator found in base.py ( u.dx(i) )
 (- Probably shouldn't do this: express all other operators in terms of partial derivative operator.)

# Algorithms:
 - Clean up existing algorithms, they're probably broken now. Define more, define tests.
 - Implement conversion function that converts diffoperators Grad,Div,Curl to index notation
 - Implement conversion function that converts tensoroperators Inner, Dot, etc to index notation
 - Implement contraction function that expands all implicit summations into Sums

# License:
 - Which license do we pick? GPL3 or LGPL3?


- Elaborate more on the feature list on the wiki, trying to exhaust all ideas we have

- Define syntactic tests

- Discuss implementation approach (base on sympy? depends on the complexity we want)

- Finish implementation of UFL prototype such that all the syntactic tests pass

- Define tests that require a form compiler and verifies the computed element tensors
  (can use ufc_benchmark module and compare with results from existing working form compiler implementations)

- Implement utility algorithms that aid in the implementation of form compilers

- Implement UFL support in form compilers

- Make all tests pass for all form compiler configurations!

* Notes by Anders (trying to make sense of the implementation)

  OK   = Understand it and it looks ok
  OK!  = Understand it and it looks really good (done)
  ??   = Don't understand this module (yet)
  --   = Undecided
  hmm  = Skeptical

  elements.py                OK
  all.py                     --
  differentiation.py         --
  geometry.py                --
  mathfunctions.py           --
  predicates.py              --
  transformers.py            --
  base.py                    --
  finiteelement.py           --
  indexing.py                --
  objects.py                 --
  swiginac_code.py           --
  traversal.py               --
  basisfunctions.py          --
  formoperators.py           --
  __init__.py                --
  operators.py               --
  tensoralgebra.py           --
  utilities.py               --
  checks.py                  --
  form.py                    --
  integral.py                --
  output.py                  --
  tensors.py                 --
  visitor.py                 --
