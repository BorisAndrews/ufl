Roadmap for the development of UFL
----------------------------------

# Figure out allowed shape/free index combinations:
 - Sums of operands with different free indices can not be allowed. Need to work around in AD!

   Examples:

   A)  a = 5 + v[i]; b = a*c[i] 

       Expanding the implicit sum, this gives us:
         b = sum_i [ (5+v_i) c_i ]      # remember, 'a = 5 + v[i]' is an Add object
          != 5 c_i + sum_i [ v_i c_i ]  # this would still have a free index
       or
         (5+v[i])*c[i] != 5*c[i] + v[i]*c[i]

       - Clearly, this last line isn't what we would expect!
       - We really don't want to inspect the contents of "a" further,
         or we get a blowup of special cases!

   B)  a = b(x) + c
       f = da/dx_i
         = db/dx_i + dc/dx_i
         = db/dx_i + zero(i) # we have currently special-cased zero to carry free indices

   C)  a = b(x) * c
       f = da/dx_i
         = db/dx_i * c + b * dc/dx_i
         = db/dx_i * c + b * zero(i)
         = db/dx_i * c

# Derivatives:
 - Finish forward mode AD implementation and verify correctness
 - Finish reverse mode AD implementation and compare performance
 - Currently, FunctionDerivative doesn't work multiple times. Fix that!

# About canonical form of forms and expressions:
 - The current way of comparing forms and expressions using repr isn't
   good enough for all purposes, since repr depends on the global counters 
   of Counted objects (that is, Index, BasisFunction and Function with subclasses).
   Some ideas to get around this:
   - Implement renumbering of BasisFunction and Function objects to
     correctly compare forms (this is mostly for form compiler cache)
     (can extract original BF and F objects in FormData before applying this)
   - Implement a consistent renumbering of indices to compare arbitrary
     expressions better (apply before mark_duplications to improve cse as well?)
     A complication w.r.t. renumbering of indices is that indices may need
     to be relabeled to match, which can of course be handled by inserting
     ComponentTensor and Indexed objects.
     - In an index renumbering algorithm, we must take great care to avoid
       implicit dependencies of the index numbering on the previous numberings!
       (The ordering of operands may depend on previous numbering!)
     - Indices may be _introduced_ in the expression tree in the following node types only:
       - Indexed
       - SpatialDerivative
     - Indices may be mapped from free to repeated in the following node types only:
       - Indexed (A[i,i])
       - SpatialDerivative (A[i].dx(i))
       - Product (A[i,j]*B[j,k])
       In all other nodes, indices just fall through
   (- Maybe introducing a class ImplicitSum (which represents the sum of an
     expression (product/spatialderivative/indexed) over its repeated indices)
     can simplify some algorithms?)
 (- Maybe we should keep a more conservative representation of expressions,
   and move simplifications from __new__ to separate functions?
   Pros and cons? Bad during AD, lots of expressions created automatically that can cancel out.)

# Elements and Basisfunctions (medium priority, needed for non-trivial applications):
 - Implement 'Test/Trial/BasisFunctions' for general tensor subelement with arbitrary symmetries (see split.py). Need to agree on some numbering conventions here.
 - Degree range for quadrature elements?
 - Add integration method information to Integral. In particular we want to add
   quadrature order or weights/points, but maybe also other metadata is possible.
 - Implement
    class ElementUnion(FiniteElementBase):
        def __init__(self, *elements):
            ...
   to represent the enrichment of a finite element space with another. (Idea from Marie)
 - Time elements

# Algorithms:
 - Computing quadrature degree.
 - If AD needs to be applied in a compiler context, we need a framework
   for representing unapplied form transformations.
 - Test implementations of lhs, rhs, and other form transformations.
 (- Implement contraction function that expands all implicit summations
    into Sums (do we need this? can be merged with evaluation anyway) )

# Prettyness and readability (medium priority, useful while debugging...):
 - Rewrite ufl2latex as described in its comments (use pre- and post-handlers)
 - Use precedence list to improve parentesis use in __str__ and __repr__ and ufl2latex. 
 - Improve dot-rendering with compact symbols for all node types (evt add option to switch between repr style and greek style)

# Class hierarchy changes:
 - Make IndexBase an Expr? Affects the following in particular:
    indexing.py - Make IndexBase an Expr?
    sorting.py - Remove MultiIndex handling if we make IndexBase an Expr.

# Tests:
 - Write tests for the algorithms, ideally covering all code in multiple ways.

# Documentation:
 - Write the manual/paper/book chapter (can perhaps reuse some text I have)
 - Rewrite/improve all error messages (collect strings in separate file?)
 - Improve operator docstrings (use epydoc @param and @return for the more complicated functions)

# Time derivatives (low priority):
 - Do we want something like Dt(u), Dtt(u), CR(a), FE(a), BE(a), TR(a, theta)?
 - In particular, this can be interesting in combination with time elements?
     es = FiniteElement("CG", triangle, 1)
     et = TimeElement(1) # Any point in non-Galerkin elements?
     e = es*et
     v = TestFunction(e)
     u = TrialFunction(e)
     f = Function(es)
     g = Function(e)
     a = f*u*v*dx
   Need to extend ufc::cell for this, perhaps adding time interval [t0,t1] as part 
   of ufc::cell, new shapes time_triangle etc and bool is_time_dependent() to form.

# License:
 - Which license do we pick? GPL3 or LGPL3?

   I (Martin) chose GPL3 for now, but if another licence is
   requested for a good reason I'm not a fanatic.
   I would like to understand the implications of choosing
   one over the other for a Python module. In particular, GPL can't
   inhibit importing and using UFL in another library, right?
   
   What I want to achieve is this:
   If someone wants to make modifications to UFL without sharing
   them with the FEniCS community, and use their modified version in 
   a proprietary library or program, they should at least pay for it.
   Thus GPL seems the right choice. Does this inhibit any usage we want?

   Of course, UFL will be a central part of FEniCS, so objections
   from main developers in FEniCS will carry much weight even though
   they are not UFL developers.


* Notes by Anders (trying to make sense of the implementation)

  OK   = Understand it and it looks ok
  OK!  = Understand it and it looks really good (done)
  ??   = Don't understand this module (yet)
  --   = Undecided
  hmm  = Skeptical

Martin to Anders: I entered the new filenames below without comments.

  algebra.py              OK!
  base.py                 OK!
  baseoperators.py        --
  basisfunctions.py       --
  common.py               OK!
  classes.py              --
  conditionals.py         --
  differentiation.py      --
  elements.py             OK!
  finiteelement.py        OK!
  formoperators.py        --
  form.py                 --
  geometry.py             --
  indexing.py             --
  __init__.py             --
  integral.py             --
  mathfunctions.py        OK!
  objects.py              --
  operators.py            --
  output.py               OK!
  permutation.py          OK!
  restriction.py          --
  tensoralgebra.py        --
  tensors.py              --
  variable.py             --

  algorithms/__init__.py         --
  algorithms/analysis.py         --
  algorithms/ad.py               --
  algorithms/checks.py           --
  algorithms/predicates.py       --
  algorithms/transformations.py  --
  algorithms/traversal.py        --
  algorithms/utilities.py        Rename to algorithm(s).py

New filenames:

  algebra.py             --
  baseoperators.py       --
  base.py                --
  basisfunction.py       --
  classes.py             --
  common.py              --
  conditional.py         --
  differentiation.py     --
  elements.py            --
  finiteelement.py       --
  formoperators.py       --
  form.py                --
  function.py            --
  geometry.py            --
  indexing.py            --
  __init__.py            --
  integral.py            --
  mathfunctions.py       --
  objects.py             --
  operators.py           --
  output.py              --
  permutation.py         --
  restriction.py         --
  split.py               --
  tensoralgebra.py       --
  tensors.py             --
  variable.py            --

  algorithms/
    ad.py                    --
    analysis.py              --
    checks.py                --
    dependencies.py          --
    formdata.py              --
    formfiles.py             --
    formtransformations.py   --
    indexalgorithms.py       --
    __init__.py              --
    predicates.py            --
    printing.py              --
    transformations.py       --
    traversal.py             --
    ufl2latex.py             --
    variables.py             --

