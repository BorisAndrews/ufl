Roadmap for the development of UFL
----------------------------------

Some of the TODO's left:

- Main issue groups:
  - Evaluation algorithms for form compiler use
  - AD
  - Other form-level transformations

# Derivatives:
 - Rename Diff to e.g. VariableDerivative?
 - Consider the results of splitting class Variable into two classes Variable (non-terminal, for Diff) and Token (terminal, for building code structure)
 - Apply AD to computation of Derivative, SpatialDiff and Diff.
 - Find a smart way to handle nested AD:
    - Collapse nested SpatialDiff into a single SpatialDiff with multiple indices, sorted since they commute.
 - Use Variable during AD to cache subexpressions we can reuse. Do we want to do this on the single operation level or on groups of operations?
 - Figure out issues with diff w.r.t. tensor variable

# Tensors:
 - ComponentTensor needs to get the dimensions of its expression in its "free index axes" to determine its shape correctly

# Algorithms:
 - Implement contraction function that expands all implicit summations into Sums (do we need this? can be merged with evaluation anyway)
 - Implement evaluation function for swiginac and sympy, given expressions for all terminals.

# Elements and Basisfunctions (only minor or rare issues left):
 - Implement 'Test/Trial/BasisFunctions' for general tensor subelement with arbitrary symmetries
   FIXME: Need to agree on some numbering conventions here.
 - Add Cell support for high order geometries?
     cell = Cell("triangle", 2)
     element = FiniteElement("CG", cell, 1)
 - Add FunctionSpace concept?
     g = Function(element)
     V = FunctionSpace(element, trace=g)
     u = BasisFunction(V)
 - Keep or drop 'name' in Function? Can eventually pass it to UFC if we add a "form::coefficient_name(i)" function.
 - Degree range for quadrature elements?

# Form-level operators:
 - Implement lhs, rhs, and other form transformations.

# Tests:
 - Write tests for the algorithms, ideally covering all code in multiple ways.

# Documentation:
 - Write the manual/paper/book chapter (can perhaps reuse some text I have)
 - Rewrite/improve all error messages (collect strings in separate file?)
 - Improve operator docstrings (use epydoc @param and @return?)

# Prettyness and readability (can wait):
 - Improve parentesis use in __str__ and __repr__ and ufl2latex, use precedence list

# Time derivatives (can wait):
 - Do we want something like Dt(u), Dtt(u), CR(a), FE(a), BE(a), TR(a, theta)?
 - Interesting in combination with time elements?

# Physical units (can wait):
 - Utility algorithms for validating the physical dimensions in a form.
   Input:
    - A form or expression
    - A mapping between Terminals (Function or BasisFunction instances)
      and physical units (using ScientificPython or something)
   Output:
    - Validation results (list of possible problems we can detect):
        - Some operators require equal units in their operands, e.g. Sum.
        - Some operators multiply the units, e.g. Product, Dot, Inner, etc.
        - Some operators divide the units, e.g. Division, Inverse.
        - Some operators require dimensionless operands, e.g. Exp, Ln.
      These considerations are not necessarily errors, maybe some
      things can be defined as warnings. Also, we would have to add
      physical units to all terminals to make this truly useful.

# License:
 - Which license do we pick? GPL3 or LGPL3?

* Notes by Anders (trying to make sense of the implementation)

  OK   = Understand it and it looks ok
  OK!  = Understand it and it looks really good (done)
  ??   = Don't understand this module (yet)
  --   = Undecided
  hmm  = Skeptical

  algebra.py              OK!
  base.py                 OK!
  baseoperators.py        --
  basisfunctions.py       --
  common.py               OK!
  classes.py              --
  conditionals.py         --
  differentiation.py      --
  elements.py             OK!
  finiteelement.py        OK!
  formoperators.py        --
  form.py                 --
  geometry.py             --
  indexing.py             --
  __init__.py             --
  integral.py             --
  mathfunctions.py        OK!
  objects.py              --
  operators.py            --
  output.py               OK!
  permutation.py          OK!
  restriction.py          --
  tensoralgebra.py        --
  tensors.py              --
  variable.py             --

  algorithms/__init__.py         --
  algorithms/analysis.py         --
  algorithms/ad.py               --
  algorithms/checks.py           --
  algorithms/predicates.py       --
  algorithms/transformations.py  --
  algorithms/traversal.py        --
  algorithms/utilities.py        Rename to algorithm(s).py
