Roadmap for the development of UFL
----------------------------------

# About canonical form of forms and expressions:
 - Maybe we should keep a more conservative representation of expressions,
   and move simplifications from __new__ to separate functions?
   Pros and cons?
 - The current way of comparing forms and expressions using repr isn't
   good enough, since repr depends on the global counters of Counted
   objects (that is, Index, BasisFunction and Function with subclasses).
   Some ideas to get around this:
   - Implement renumbering of BasisFunction and Function objects to
     correctly compare forms (this is mostly for form compiler cache)
     (can extract original BF and F objects in FormData before applying this)
   - Implement a consistent renumbering of indices to compare arbitrary
     expressions better (apply before mark_duplications to improve cse as well?)
     A complication w.r.t. renumbering of indices is that indices may need
     to be relabeled to match, which can of course be handled by inserting
     ComponentTensor and Indexed objects.
     - In an index renumbering algorithm, we must take great care to avoid
       implicit dependencies of the index numbering on the previous numberings!
       (The ordering of operands may depend on previous numbering!)
     - Indices may be introduced in the expression tree in the following node types only:
       - Indexed
       - SpatialDerivative
     - Indices may be mapped from free to repeated in the following node types only:
       - Indexed (A[i,i])
       - SpatialDerivative (A[i].dx(i) or A.dx(i,i))
       - Product (A[i,j]*B[j,k])
       In all other nodes, indices just fall through
   (- Maybe introducing a class ImplicitSum which represents the sum of an
     expression (product or derivative or indexed) over its repeated indices
     can simplify some algorithms?)

# Derivatives:
 - Apply AD to computation of
    - SpatialDerivative (propagating to terminal nodes)
        - Find a smart way to handle nested AD:
            - Collapse nested SpatialDerivative into a single SpatialDerivative with multiple indices, sorted since they commute.
    - VariableDerivative (no traces left afterwards)
        - Figure out issues with diff w.r.t. tensor variable
 - Implement Variable cache in AD.
 - Do we want to do this on the single operation level or on groups of operations?
   Groups of operations where possible would be best, e.g. same abstraction level as the input expression tree.
 - Read up on AD and improve implementation (actually, currently it's more like pure symbolic differentiation)

# Elements and Basisfunctions (medium priority, needed for non-trivial applications):
 - Implement 'Test/Trial/BasisFunctions' for general tensor subelement with arbitrary symmetries (see split.py). Need to agree on some numbering conventions here.
 - Degree range for quadrature elements?
 - Add integration method information to Integral. In particular we want to add
   quadrature order or weights/points, but maybe also other metadata is possible.
 - Implement
    class ElementUnion(FiniteElementBase):
        def __init__(self, *elements):
            ...
   to represent the enrichment of a finite element space with another.
 - Time elements

# Algorithms:
 - Computing quadrature degree.
 - If AD needs to be applied in a compiler context, we need a framework
   for representing unapplied form transformations.
 - Test implementations of lhs, rhs, and other form transformations.
 (- Implement contraction function that expands all implicit summations
    into Sums (do we need this? can be merged with evaluation anyway) )

# Prettyness and readability (medium priority, useful while debugging...):
 - Rewrite ufl2latex as described in its comments (use pre- and post-handlers)
 - Use precedence list to improve parentesis use in __str__ and __repr__ and ufl2latex. 
 - Improve dot-rendering with compact symbols for all node types (evt add option to switch between repr style and greek style)

# Tests:
 - Write tests for the algorithms, ideally covering all code in multiple ways.

# Documentation:
 - Write the manual/paper/book chapter (can perhaps reuse some text I have)
 - Rewrite/improve all error messages (collect strings in separate file?)
 - Improve operator docstrings (use epydoc @param and @return?)

# Time derivatives (low priority):
 - Do we want something like Dt(u), Dtt(u), CR(a), FE(a), BE(a), TR(a, theta)?
 - In particular, this can be interesting in combination with time elements?
     es = FiniteElement("CG", triangle, 1)
     et = TimeElement(1) # Any point in non-Galerkin elements?
     e = es*et
     v = TestFunction(e)
     u = TrialFunction(e)
     f = Function(es)
     g = Function(e)
     a = f*u*v*dx
   Need to extend ufc::cell for this, perhaps adding time interval [t0,t1] as part 
   of ufc::cell, new shapes time_triangle etc and bool is_time_dependent() to form.

# License:
 - Which license do we pick? GPL3 or LGPL3?

   I (Martin) chose GPL3 for now, but if another licence is
   requested for a good reason I'm not a fanatic.
   I would like to understand the implications of choosing
   one over the other for a Python module. In particular, GPL can't
   inhibit importing and using UFL in another library, right?
   
   What I want to achieve is this:
   If someone wants to make modifications to UFL without sharing
   them with the FEniCS community, and use their modified version in 
   a proprietary library or program, they should at least pay for it.
   Thus GPL seems the right choice. Does this inhibit any usage we want?

   Of course, UFL will be a central part of FEniCS, so objections
   from main developers in FEniCS will carry much weight even though
   they are not UFL developers.


* Notes by Anders (trying to make sense of the implementation)

  OK   = Understand it and it looks ok
  OK!  = Understand it and it looks really good (done)
  ??   = Don't understand this module (yet)
  --   = Undecided
  hmm  = Skeptical

Martin to Anders: I entered the new filenames below without comments.

  algebra.py              OK!
  base.py                 OK!
  baseoperators.py        --
  basisfunctions.py       --
  common.py               OK!
  classes.py              --
  conditionals.py         --
  differentiation.py      --
  elements.py             OK!
  finiteelement.py        OK!
  formoperators.py        --
  form.py                 --
  geometry.py             --
  indexing.py             --
  __init__.py             --
  integral.py             --
  mathfunctions.py        OK!
  objects.py              --
  operators.py            --
  output.py               OK!
  permutation.py          OK!
  restriction.py          --
  tensoralgebra.py        --
  tensors.py              --
  variable.py             --

  algorithms/__init__.py         --
  algorithms/analysis.py         --
  algorithms/ad.py               --
  algorithms/checks.py           --
  algorithms/predicates.py       --
  algorithms/transformations.py  --
  algorithms/traversal.py        --
  algorithms/utilities.py        Rename to algorithm(s).py

New filenames:

  algebra.py             --
  baseoperators.py       --
  base.py                --
  basisfunction.py       --
  classes.py             --
  common.py              --
  conditional.py         --
  differentiation.py     --
  elements.py            --
  finiteelement.py       --
  formoperators.py       --
  form.py                --
  function.py            --
  geometry.py            --
  indexing.py            --
  __init__.py            --
  integral.py            --
  mathfunctions.py       --
  objects.py             --
  operators.py           --
  output.py              --
  permutation.py         --
  restriction.py         --
  split.py               --
  tensoralgebra.py       --
  tensors.py             --
  variable.py            --

  algorithms/
    ad.py                    --
    analysis.py              --
    checks.py                --
    dependencies.py          --
    formdata.py              --
    formfiles.py             --
    formtransformations.py   --
    indexalgorithms.py       --
    __init__.py              --
    predicates.py            --
    printing.py              --
    transformations.py       --
    traversal.py             --
    ufl2latex.py             --
    variables.py             --

