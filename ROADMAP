Roadmap for the development of UFL
----------------------------------

Some of the TODO's left:

# Tensor handling:
 - Do we need UFLObject.repeated_indices()?
 - Do we need UFLObject.free_index_dimensions()?
 - Test and finalize class Tensor.

# Derivatives:
 - Finish Diff design, including index handling like in PartialDiff and Product. Generalize index handling more?
 - Apply Variable during AD to cache subexpressions we can reuse.
 - Find a smart way to handle nested AD.
 - Apply AD to computation of Derivative, PartialDiff (really SpatialDiff) and Diff.

# Algorithms:
 - Implement contraction function that expands all implicit summations into Sums
 - Implement evaluation function for swiginac and sympy, given expressions for each basisfunction and function.
 - Several small details and much testing remains in existing algorithms

# Elements and Basisfunctions (only minor or rare issues left):
 - Implement 'Test/Trial/BasisFunctions' for general tensor subelement with arbitrary symmetries
 - Add Cell support for high order geometries?
 - Keep or drop name from Function? Can eventually pass it to UFC if we add a "form::coefficient_name(i)" function.
 - Degree range for quadrature elements?
 - Agree on final design!

# Form-level operators:
 - Framework for applying these to parts of a form?
 - Implementations of lhs, rhs, action, derivative...

# Tests:
 - Implement more elaborate tests, some operators aren't tested, and only a few of the algorithms.

# Documentation:
 - Write the manual (can perhaps reuse some text I have)
 - Write the paper/book chapter (can perhaps reuse some text I have)
 - Improve operator docstrings (use epydoc @param and @return?)
 - Rewrite/improve all error messages

# Prettyness and readability (can wait):
 - Improve parentesis use in __str__ and __repr__ and ufl2latex, use precedence list

# Time derivatives (can wait):
 - Do we want something like Dt(u), Dtt(u), CR(a), FE(a), BE(a), TR(a, theta)? 

# License:
 - Which license do we pick? GPL3 or LGPL3?

* Notes by Anders (trying to make sense of the implementation)

  OK   = Understand it and it looks ok
  OK!  = Understand it and it looks really good (done)
  ??   = Don't understand this module (yet)
  --   = Undecided
  hmm  = Skeptical

  algebra.py              OK!
  base.py                 OK!
  baseoperators.py        --
  basisfunctions.py       --
  common.py               OK!
  classes.py              --
  conditionals.py         --
  differentiation.py      --
  elements.py             OK!
  finiteelement.py        OK!
  formoperators.py        --
  form.py                 --
  geometry.py             --
  indexing.py             --
  __init__.py             --
  integral.py             --
  mathfunctions.py        OK!
  objects.py              --
  operators.py            --
  output.py               OK!
  permutation.py          OK!
  restriction.py          --
  tensoralgebra.py        --
  tensors.py              --
  variable.py             --

  algorithms/__init__.py         --
  algorithms/analysis.py         --
  algorithms/ad.py               --
  algorithms/checks.py           --
  algorithms/predicates.py       --
  algorithms/transformations.py  --
  algorithms/traversal.py        --
  algorithms/utilities.py        Rename to algorithm(s).py
