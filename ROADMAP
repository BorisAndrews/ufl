Roadmap for the development of UFL
----------------------------------

- Work out various issues with extract_indices!

# Martins plan:
- Improve ufl2latex with pre- and post-handlers.
- Improve ufl2latex with precedence lists.
- Test and fix mark_duplications.
- Test and fix split_by_dependencies.
- Test and fix replace_in_form.
- Test and fix AD algorithms on spatial derivatives.
- Test and fix AD algorithms on variable derivatives.
- Test and fix AD algorithms on functional derivatives.

# Prettyness and readability (low priority, but useful while debugging...):
 - Rewrite ufl2latex as described in its comments.
 - Use precedence list to improve parentesis use in __str__ and __repr__ and ufl2latex. 

# Derivatives:
 - Apply AD to computation of
    - SpatialDerivative (propagating to terminal nodes)
        - Find a smart way to handle nested AD:
            - Collapse nested SpatialDerivative into a single SpatialDerivative with multiple indices, sorted since they commute.
    - VariableDerivative (no traces left afterwards)
        - Figure out issues with diff w.r.t. tensor variable
 - Use Variable during AD to cache subexpressions we can reuse.
   Do we want to do this on the single operation level or on groups of operations?
   Groups of operations where possible would be best, e.g. same abstraction level as the input expression tree.

# Algorithms:
 - Update these algorithms with better Variable handling:
 	- mark_duplications (has some issues after adding variable cache)
 	- AD algorithms (needs variable cache and diff cache)
 	- split_by_dependencies (might be SFC specific)
    - replace_in_form (replace inside variables!)
 	- other?
 (- Implement contraction function that expands all implicit summations
    into Sums (do we need this? can be merged with evaluation anyway) )
 - Implement lhs, rhs, and other form transformations.

# Various issues with Variable: (write down issues as they occur here to get a better overview!)
 - Figure out implications of a Variable with free indices.
   How does various algorithms deal with this?
   Will it affect expression simplification?
 - Figure out issues with diff w.r.t. tensor variable and indexed tensor variable.
 - Consider the results of splitting class Variable into two classes:
     - Variable (non-terminal, for VariableDerivative use)
     - Token (terminal, for building code structure)
   One problem is that Variable needs to be identified by something,
   currently a global counter, and algorithms that modify expression
   trees needs 

# Elements and Basisfunctions:
 - Implement 'Test/Trial/BasisFunctions' for general tensor subelement with arbitrary symmetries (see split.py). Need to agree on some numbering conventions here.
 - Degree range for quadrature elements?

# Tensors:
 - ComponentTensor needs to get the dimensions of its expression 
   in its "free index axes" to determine its shape correctly.
   Currently this is done using only default dimensions,
   which will be wrong in some cases. This is a tricky issue,
   but won't be a problem for most applications.

# Tests:
 - Write tests for the algorithms, ideally covering all code in multiple ways.

# Documentation:
 - Write the manual/paper/book chapter (can perhaps reuse some text I have)
 - Rewrite/improve all error messages (collect strings in separate file?)
 - Improve operator docstrings (use epydoc @param and @return?)

# High order geometries (low priority):
 - Add Cell support for high order geometries?
     cell = Cell("triangle", 2)
     element = FiniteElement("CG", cell, 1)

# Time derivatives (low priority):
 - Do we want something like Dt(u), Dtt(u), CR(a), FE(a), BE(a), TR(a, theta)?
 - In particular, this can be interesting in combination with time elements?
     es = FiniteElement("CG", "triangle", 1)
     et = TimeElement(1) # Any point in non-Galerkin elements?
     e = es*et
     v = TestFunction(e)
     u = TrialFunction(e)
     f = Function(es)
     g = Function(e)
     a = f*u*v*dx
   Need to extend ufc::cell for this, perhaps adding time interval [t0,t1] as part 
   of ufc::cell, new shapes time_triangle etc and bool is_time_dependent() to form.

# Dirichlet boundary conditions (low priority):
 - Add FunctionSpace concept?
     g = Function(element)
     V = FunctionSpace(element, trace=g)
     u = BasisFunction(V)
   Must also handle traces of functions on any subboundary.
   The code gain versus defining a DirichletBC in PyDOLFIN seems minimal.

# Physical units (very low priority):
 - Utility algorithms for validating the physical dimensions in a form.
   Input:
    - A form or expression
    - A mapping between Terminals (Function or BasisFunction instances)
      and physical units (using ScientificPython or something)
   Output:
    - Validation results (list of possible problems we can detect):
      - Some operators require equal units in their operands, e.g. Sum.
      - Some operators multiply the units, e.g. Product, Dot, Inner, etc.
      - Some operators divide the units, e.g. Division, Inverse.
      - Some operators require dimensionless operands, e.g. Exp, Ln.
      These considerations are not necessarily errors, maybe some
      things can be defined as warnings. Also, we would have to add
      physical units to all terminals to make this truly useful.

# License:
 - Which license do we pick? GPL3 or LGPL3?

   I (Martin) chose GPL3 for now, but if another licence is
   requested for a good reason I'm not a fanatic.
   I would like to understand the implications of choosing
   one over the other for a Python module. In particular, GPL can't
   inhibit importing and using UFL in another library, right?
   
   What I want to achieve is this:
   If someone wants to make modifications to UFL without sharing
   them with the FEniCS community, and use their modified version in 
   a proprietary library or program, they should at least pay for it.
   Thus GPL seems the right choice. Does this inhibit any usage we want?

   Of course, UFL will be a central part of FEniCS, so objections
   from main developers in FEniCS will carry much weight even though
   they are not UFL developers.


* Notes by Anders (trying to make sense of the implementation)

  OK   = Understand it and it looks ok
  OK!  = Understand it and it looks really good (done)
  ??   = Don't understand this module (yet)
  --   = Undecided
  hmm  = Skeptical

Martin to Anders: I entered the new filenames below without comments.

  algebra.py              OK!
  base.py                 OK!
  baseoperators.py        --
  basisfunctions.py       --
  common.py               OK!
  classes.py              --
  conditionals.py         --
  differentiation.py      --
  elements.py             OK!
  finiteelement.py        OK!
  formoperators.py        --
  form.py                 --
  geometry.py             --
  indexing.py             --
  __init__.py             --
  integral.py             --
  mathfunctions.py        OK!
  objects.py              --
  operators.py            --
  output.py               OK!
  permutation.py          OK!
  restriction.py          --
  tensoralgebra.py        --
  tensors.py              --
  variable.py             --

  algorithms/__init__.py         --
  algorithms/analysis.py         --
  algorithms/ad.py               --
  algorithms/checks.py           --
  algorithms/predicates.py       --
  algorithms/transformations.py  --
  algorithms/traversal.py        --
  algorithms/utilities.py        Rename to algorithm(s).py

New filenames:

  algebra.py             --
  baseoperators.py       --
  base.py                --
  basisfunction.py       --
  classes.py             --
  common.py              --
  conditional.py         --
  differentiation.py     --
  elements.py            --
  finiteelement.py       --
  formoperators.py       --
  form.py                --
  function.py            --
  geometry.py            --
  indexing.py            --
  __init__.py            --
  integral.py            --
  mathfunctions.py       --
  objects.py             --
  operators.py           --
  output.py              --
  permutation.py         --
  restriction.py         --
  split.py               --
  tensoralgebra.py       --
  tensors.py             --
  variable.py            --

  algorithms/
    ad.py                    --
    analysis.py              --
    checks.py                --
    dependencies.py          --
    formdata.py              --
    formfiles.py             --
    formtransformations.py   --
    indexalgorithms.py       --
    __init__.py              --
    predicates.py            --
    printing.py              --
    transformations.py       --
    traversal.py             --
    ufl2latex.py             --
    variables.py             --

